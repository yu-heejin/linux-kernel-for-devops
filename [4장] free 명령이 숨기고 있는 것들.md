메모리는 커널이 제공하는 중요한 리소스 중 하나이다. CPU가 프로세스의 연산 과정에 필요한 리소스라고 한다면, **메모리는 프로세스가 연산할 수 있는 공간을 제공해주는 리소스라고 할 수 있다.** 프로세스는 메모리라는 공간에 자신이 필요한 함수를 넣어두거나 변수에 값을 저장하거나 하는 방식으로 연산을 위한 공간을 확보하고 작업을 진행한다. 메모리가 부족하다면 프로세스는 더 이상 연산을 위한 공간을 확보할 수 없고, 이는 시스템 응답 불가 현상 또는 큰 성능 저하를 일으킬 수 있다. 그렇기 때문에 메모리가 어떻게 활용되고 있는지를 파악하는 것은 CPU 사용률과 Load Average 만큼 중요한 포인트이다.

# 4.1 메모리 사용량 확인하기

리눅스 시스템에서 메모리의 전체적인 현황을 가장 빠르게 살펴볼 수 있는 명령은 `free` 명령이다. `free` 명령은 전체 메모리 용량과, 사용 중인 용량, 그리고 buffers와 cached로 명명되는 캐싱 영역의 용량을 확인하는데 사용된다.

아래는 `free` 명령의 출력 결과이다.

```c
ubuntu@ip-172-31-0-119:~$ free -m
               total        used        free      shared  buff/cache   available
Mem:             957         318         154           0         642         638
Swap:              0           0           0
```

- Mem
    - total: 현재 시스템에 설치되어 있는 전체 메모리 양을 의미한다. `-m`을 옵션으로 주었기 때문에 MB 단위로 표시한다.
    - used: 시스템에서 사용하고 있는 메모리 양을 의미한다. 이 시스템은 957MB 중에서 318MB를 사용하고 있다.
    - free: 시스템에서 아직 사용하고 있지 않는 메모리 양을 의미한다. 그야말로 아무도 사용하고 있지 않기 때문에 애플리케이션이 사용할 수도 있고, 커널이 사용할 수도 있다.
    - shared: 프로세스 사이에 공유하고 있는 메모리 양이다. 출력에는 MB 단위라서 0으로 출력되었지만 단위를 더 낮추면 값이 보일 수 있다.
    - buffers: 버퍼 용도로 사용하고 있는 메모리 양을 의미한다. 프로세스가 사용하는 메모리 영역이 아니고 시스템의 성능 향상을 위해서 커널에서 사용하고 있는 영역이다.
    - cached: 페이지 캐시라고 불리는 캐시 영역에 있는 메모리 양을 의미한다. I/O 관련 작업을 더 빠르게 진행하기 위해 커널에서 사용하고 있는 영역이다.
- buffers/cache(buff/cache): 첫번째 줄의 결과에서 buffers와 cached 영역을 제외한 양을 보여준다는 의미이다. buffers와 cached 영역을 제외하고 사용하고 있는 영역을 의미한다.
    - free: buffers와 cache영역을 제외하고 사용하지 않는 영역을 의미한다. 첫번째 줄에서 볼 수 있는 free 영역보다 더 큰 값을 볼 수 있다.
- Swap
    - total: swap 영역의 전체 용량을 보여준다.
    - used: swap 영역 중 실제로 사용하고 있는 영역에 대한 정보이다.
    - free: swap 영역 중 사용하지 않은 영역에 대한 정보이다.

# 4.2 buffers와 cached 영역

커널은 블록 디바이스라고 부르는 디스크로부터 데이터를 읽거나 사용자의 데이터를 디스크에 저장한다. 하지만 디스크는 다른 장치들에 비해 매우 느리기 때문에 디스크에 대한 요청을 기다리는 시간이 상당히 많이 소요되고, 이로 인해 시스템에 부하가 일어나기도 한다. **커널은 이렇게 상대적으로 느린 디스크에 대한 요청을 좀 더 빠르게 하기 위해 메모리의 일부를 디스크 요청에 대한 캐싱 영역으로 할당해서 사용한다. 즉, 한번 읽은 디스크의 내용을 메모리에 저장해 두어서, 동일한 내용을 읽고자 하면 디스크로 요청하지 않고 메모리로 요청하게 된다.** 이런 캐싱 기능을 통해서 커널은 다수의 디스크 요청을 좀 더 빠르게 처리할 수 있다. 그리고 이때 사용되는 캐싱 영역을 buffers, cached라고 부른다.

커널은 블록 디바이스에서 데이터를 읽을 때 데이터가 위치한 특정 블록의 주소를 넘겨주고, 블록 디바이스는 해당 블록 주소의 데이터를 커널에 전달한다. 이 과정에 디바이스 드라이버가 있다. 커널이 읽어야 할 데이터가 파일의 내용이라면 커널은 bio 구조체를 만들고 해당 구조체에 Page Cache 용도로 할당한 메모리 영역을 연결해준다. 그리고 bio 구조체는 디바이스 드라이버와 통신해서 디스크로부터 데이터를 읽어서 Page Cache에 파일의 내용을 채운다.

[[Block I/O Layer] 3. bio struct](https://gksruf0326.tistory.com/7)

[[Linux Kernel 5] Block Device Driver Basic Concept](https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-Block-Device-Driver-Basic-Concept)

[Linux Device Driver 정리 (1)](https://tribal1012.tistory.com/154)

[파일시스템 기본 - Sector & Cluster Ⅱ](https://myung-dfc.tistory.com/19)

super block, inode block처럼 파일의 내용이 아닌 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 때는 bio 구조체를 사용하지 않고 `_get_blk()`와 같은 내부 함수를 통해 블록 디바이스와 직접 통신한다. 그리고 이때 가져온 블록 디바이스의 특정 블록 내용을 Buffer Cache 영역에 저장해 둔다.

**정리하자면 Page Cache는 파일의 내용을 저장하고 있는 캐시, Buffer Cache는 파일 시스템의 메타 데이터를 담고 있는 블록을 저장하고 있는 캐시라고 할 수 있다. 그리고 각각이 `free` 에서 표현하고 있는 cached, buffers 영역이다.**

그렇다면 `free` 명령은 왜 이 두 영역을 제외한 영역을 가용한 영역으로 계산해서 다시 보여주는걸까?
