메모리는 커널이 제공하는 중요한 리소스 중 하나이다. CPU가 프로세스의 연산 과정에 필요한 리소스라고 한다면, **메모리는 프로세스가 연산할 수 있는 공간을 제공해주는 리소스라고 할 수 있다.** 프로세스는 메모리라는 공간에 자신이 필요한 함수를 넣어두거나 변수에 값을 저장하거나 하는 방식으로 연산을 위한 공간을 확보하고 작업을 진행한다. 메모리가 부족하다면 프로세스는 더 이상 연산을 위한 공간을 확보할 수 없고, 이는 시스템 응답 불가 현상 또는 큰 성능 저하를 일으킬 수 있다. 그렇기 때문에 메모리가 어떻게 활용되고 있는지를 파악하는 것은 CPU 사용률과 Load Average 만큼 중요한 포인트이다.

# 4.1 메모리 사용량 확인하기

리눅스 시스템에서 메모리의 전체적인 현황을 가장 빠르게 살펴볼 수 있는 명령은 `free` 명령이다. `free` 명령은 전체 메모리 용량과, 사용 중인 용량, 그리고 buffers와 cached로 명명되는 캐싱 영역의 용량을 확인하는데 사용된다.

아래는 `free` 명령의 출력 결과이다.

```c
ubuntu@ip-172-31-0-119:~$ free -m
               total        used        free      shared  buff/cache   available
Mem:             957         318         154           0         642         638
Swap:              0           0           0
```

- Mem
    - total: 현재 시스템에 설치되어 있는 전체 메모리 양을 의미한다. `-m`을 옵션으로 주었기 때문에 MB 단위로 표시한다.
    - used: 시스템에서 사용하고 있는 메모리 양을 의미한다. 이 시스템은 957MB 중에서 318MB를 사용하고 있다.
    - free: 시스템에서 아직 사용하고 있지 않는 메모리 양을 의미한다. 그야말로 아무도 사용하고 있지 않기 때문에 애플리케이션이 사용할 수도 있고, 커널이 사용할 수도 있다.
    - shared: 프로세스 사이에 공유하고 있는 메모리 양이다. 출력에는 MB 단위라서 0으로 출력되었지만 단위를 더 낮추면 값이 보일 수 있다.
    - buffers: 버퍼 용도로 사용하고 있는 메모리 양을 의미한다. 프로세스가 사용하는 메모리 영역이 아니고 시스템의 성능 향상을 위해서 커널에서 사용하고 있는 영역이다.
    - cached: 페이지 캐시라고 불리는 캐시 영역에 있는 메모리 양을 의미한다. I/O 관련 작업을 더 빠르게 진행하기 위해 커널에서 사용하고 있는 영역이다.
- buffers/cache(buff/cache): 첫번째 줄의 결과에서 buffers와 cached 영역을 제외한 양을 보여준다는 의미이다. buffers와 cached 영역을 제외하고 사용하고 있는 영역을 의미한다.
    - free: buffers와 cache영역을 제외하고 사용하지 않는 영역을 의미한다. 첫번째 줄에서 볼 수 있는 free 영역보다 더 큰 값을 볼 수 있다.
- Swap
    - total: swap 영역의 전체 용량을 보여준다.
    - used: swap 영역 중 실제로 사용하고 있는 영역에 대한 정보이다.
    - free: swap 영역 중 사용하지 않은 영역에 대한 정보이다.

# 4.2 buffers와 cached 영역

커널은 블록 디바이스라고 부르는 디스크로부터 데이터를 읽거나 사용자의 데이터를 디스크에 저장한다. 하지만 디스크는 다른 장치들에 비해 매우 느리기 때문에 디스크에 대한 요청을 기다리는 시간이 상당히 많이 소요되고, 이로 인해 시스템에 부하가 일어나기도 한다. **커널은 이렇게 상대적으로 느린 디스크에 대한 요청을 좀 더 빠르게 하기 위해 메모리의 일부를 디스크 요청에 대한 캐싱 영역으로 할당해서 사용한다. 즉, 한번 읽은 디스크의 내용을 메모리에 저장해 두어서, 동일한 내용을 읽고자 하면 디스크로 요청하지 않고 메모리로 요청하게 된다.** 이런 캐싱 기능을 통해서 커널은 다수의 디스크 요청을 좀 더 빠르게 처리할 수 있다. 그리고 이때 사용되는 캐싱 영역을 buffers, cached라고 부른다.

커널은 블록 디바이스에서 데이터를 읽을 때 데이터가 위치한 특정 블록의 주소를 넘겨주고, 블록 디바이스는 해당 블록 주소의 데이터를 커널에 전달한다. 이 과정에 디바이스 드라이버가 있다. 커널이 읽어야 할 데이터가 파일의 내용이라면 커널은 bio 구조체를 만들고 해당 구조체에 Page Cache 용도로 할당한 메모리 영역을 연결해준다. 그리고 bio 구조체는 디바이스 드라이버와 통신해서 디스크로부터 데이터를 읽어서 Page Cache에 파일의 내용을 채운다.

[[Block I/O Layer] 3. bio struct](https://gksruf0326.tistory.com/7)

[[Linux Kernel 5] Block Device Driver Basic Concept](https://pr0gr4m.tistory.com/entry/Linux-Kernel-5-Block-Device-Driver-Basic-Concept)

[Linux Device Driver 정리 (1)](https://tribal1012.tistory.com/154)

[파일시스템 기본 - Sector & Cluster Ⅱ](https://myung-dfc.tistory.com/19)

super block, inode block처럼 파일의 내용이 아닌 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 때는 bio 구조체를 사용하지 않고 `_get_blk()`와 같은 내부 함수를 통해 블록 디바이스와 직접 통신한다. 그리고 이때 가져온 블록 디바이스의 특정 블록 내용을 Buffer Cache 영역에 저장해 둔다.

**정리하자면 Page Cache는 파일의 내용을 저장하고 있는 캐시, Buffer Cache는 파일 시스템의 메타 데이터를 담고 있는 블록을 저장하고 있는 캐시라고 할 수 있다. 그리고 각각이 `free` 에서 표현하고 있는 cached, buffers 영역이다.**

그렇다면 `free` 명령은 왜 이 두 영역을 제외한 영역을 가용한 영역으로 계산해서 다시 보여주는걸까? 서버의 운영 기간이 그리 길지 않을 때는 아마도 1번과 같은 메모리 사용 현황을 볼 수 있을 것이다. 아무 곳에서도 사용하지 않는 가용 영역에 있는 `free` 메모리와 애플리케이션에서 사용하고 있는 영역으로 나뉜다. 하지만 시간이 조금 지나면 **커널은 가용 영역 중 일부를 Cache 영역으로 사용하게 된다.** 그리고 시간이 흐를수록 애플리케이션에서 사용하게 되는 영역이 점점 넓어진다. 어느 순간까지는 가용 영역의 메모리를 가져다가 사용하게 될 것이다. Cache 영역이 충분히 있어야 I/O 성능 향상의 효과를 받을 수 있기 때문이다. **하지만 사용 영역이 점점 더 커져서 일정 수준 이상이 되면 커널은 Cache 영역으로 사용하던 영역을 애플리케이션이 사용할 수 있도록 메모리 관리 시스템에 반환한다.** Cache 영역이 줄고 애플리케이션의 사용 영역이 늘어난다. 이런 과정을 거치다 보면 더 이상 반환할 메모리도 없고 가용할 메모리가 없는 순간이 발생하게 되는데, **시스템은 이때부터 swap이라는 영역을 사용하게 되고 시스템의 성능이 줄어든다.**

이처럼 buffers와 cached 영역은 시스템의 I/O 성능 향상을 위해서 커널이 사용하는 영역이다. **메모리가 부족한 상황이 되면 커널은 해당 영역을 자동으로 반환하기 때문에 `free` 명령에서도 해당 영역을 제외한 영역을 실제 사용 가능한 영역으로 계산하게 된다.**

# 4.3 /proc/meminfo 읽기

리눅스에서는 /proc/meminfo를 통해서 자세한 메모리 현황을 볼 수 있는 방법을 제공하고 있다. 출력 값은 커널 버전에 따라 조금씩 다르다.

```c
MemTotal:         980304 kB
MemFree:          448008 kB
MemAvailable:     646300 kB
Buffers:           18840 kB
Cached:           320984 kB
SwapCached:            0 kB
Active:           322752 kB
Inactive:          82480 kB
Active(anon):      88016 kB
Inactive(anon):        0 kB
Active(file):     234736 kB
Inactive(file):    82480 kB
Unevictable:       40228 kB
Mlocked:           27264 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Zswap:                 0 kB
Zswapped:              0 kB
Dirty:              5232 kB
Writeback:             0 kB
AnonPages:        105704 kB
Mapped:            96516 kB
Shmem:               880 kB
KReclaimable:      17708 kB
Slab:              60068 kB
SReclaimable:      17708 kB
SUnreclaim:        42360 kB
KernelStack:        2556 kB
PageTables:         3296 kB
SecPageTables:         0 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      490152 kB
Committed_AS:     489496 kB
VmallocTotal:   34359738367 kB
VmallocUsed:        9120 kB
VmallocChunk:          0 kB
Percpu:             8128 kB
HardwareCorrupted:     0 kB
AnonHugePages:         0 kB
ShmemHugePages:        0 kB
```

- SwapCached: swap으로 빠진 메모리 영역 중 다시 메모리로 돌아온 영역을 의미한다. 메모리가 확보되어 다시 메모리로 돌아가지만, swap 영역에서 지우지는 않는다. 시스템에 메모리가 부족하면 커널은 프로세스의 주소 공간 중 swap 영역으로 이동시킬 수 있는 메모리를 선택해서 swap 영역으로 이동시킨다. 이 과정에서 I/O가 일어나기 때문에 성능 저하가 발생한다. 그 후 메모리가 다시 확보되어 swap 영역으로 빠졌던 영역이 다시 메모리로 돌아가게 되더라도 커널은 swap 영역에서 해당 메모리 내용을 삭제하지 않는다. 이후에 또다시 메모리 부족 현상이 일어날 경우를 대비하는 것이다. 해당 메모리 영역이 다시 swap 영역으로 내려와야 하는 일이 생긴다면 swap 영역으로 다시 복사하는 것이 아니라 이전에 참고한 메모리 영역을 삭제하지 않고 그대로 다시 활용한다. 이를 통해서 swap이 발생하더라도 조금이나마 I/O를 줄일 수 있다.
    
    [Swap 영역에 대해 (Swap 메모리)](https://tech-linux.tistory.com/11)
    
- Active(anon): anon은 anonymous의 줄임말이다. Anonymous가 익명이라는 뜻이 있어 오해의 소지가 있지만, 여기서는 **특정 파일의 내용을 저장하고 있는 Page Cache 영역을 제외한 메모리 영역을 의미**한다. 주로 **프로세스들이 사용하는 메모리 영역을 지칭할 때 많이 사용된다.** 그중에서도 비교적 최근에 메모리 영역이 참조되어 swap 영역으로 이동되지 않을 메모리 영역을 의미한다.
- Inactive(anon): Active와 같은 영역을 의미하지만, 비교적 참조된지 오래되어 swap 영역으로 이동될 수 있는 메모리 영역을 의미한다.
- Active(file): anon과는 다르게 file로 되어있는 이 영역은 커널이 I/O 성능 향상을 위해 사용하는 영역을 의미한다. 4.2에서 살펴보면 buffers와 cached 영역이 여기에 속한다. Active라는 이름에서 알 수 있듯이 비교적 최근까지 메모리 영역이 참조외어 Swap 영역으로 이동되지 않을 메모리 영역이다.
- Inactive(file): Active(file)과 마찬가지로 I/O 성능 향상을 위해 커널이 캐시 목적으로 사용하고 있는 영역이다. Inactive라는 단어에서 알 수 있듯이 비교적 참조된 지 오래되어 swap 영역으로 이동될 수 있는 메모리 영역이다.
- Dirty: I/O 성능 향상을 위해 커널이 캐시 목적으로 사용하는 영역 중 쓰기 작업이 이루어져서 실제 블록 디바이스의 블록에 씌어져야 할 영역을 의미한다. **커널은 기본적으로 I/O 쓰기 요청이 발생했을 때 바로 블록 디바이스로 명령을 내리지 않고 일정량이 될 때까지 모았다가 한 번에 쓰는 일종의 지연 쓰기 작업을 한다.** Dirty 메모리는 이 과정에서 사용되는 메모리 영역이다.
    
    [dirty page가 I/O에 미치는 영향](https://byungwoo.oopy.io/5188bc65-5b75-4538-a4c1-4826ea2e551c)
