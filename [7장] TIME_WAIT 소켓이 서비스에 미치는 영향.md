[TCP 통신 중 TIME_WAIT 개념](https://usheep91.tistory.com/61)

# 7.1 TCP 통신 과정

**통신을 시작하기 전에 최초의 연결을 맺게 되는 과정을 3-way handshake라고 한다.** 클라이언트는 서버로 통신을 시작하겠다는 SYN을 보내고, 서버는 그에 대한 응답으로 SYN+ACK을 보낸다. 마지막으로 클라이언트는 서버로부터 받은 패킷에 대한 응답으로 ACK을 보낸다. 이렇게 3-way handshake를 정상적으로 마친 다음 클라이언트는 서버에 데이터를 요청한다. **통신을 모두 마친 후에는 연결을 종료한다. 이 과정을 4-way handshake**라고 한다.

연결을 맺을 때는 연결을 맺고자 하는 쪽에서 먼저 SYN을 보내며, 연결을 끊을 때는 연결을 끊으려는 쪽에서 먼저 FIN을 보낸다. 클라이언트는 서버의 FIN을 받고 ACK을 보내고, 사용한 소켓을 정리한 다음 마지막 FIN을 보낸다. 서버는 클라이언트가 보낸 마지막 FIN에 대한 ACK을 전송하고 소켓을 정리한다.

<img width="2048" height="447" alt="image" src="https://github.com/user-attachments/assets/7eb932b6-1bc9-41de-a389-8afbecf84df5" />

- 데이터를 받고, 클라이언트는 ACK을 보낸다.
- 위 이미지는 클라이언트가 먼저 끊었다.
- FIN과 ACK을 같이 보낸 이유는 앞선 패킷에 대한 ACK 응답과 연결을 끊기 위한 FIN 응답을 같이 보냄

# 7.2 TIME_WAIT 소켓의 문제점

연결을 끊는 과정을 조금 더 자세히 살펴보자. 그림을 보면 active closer, passive closer가 있는데 단어 그대로 먼저 연결을 끊는 쪽을 active closer라고 하고 그 반대를 passive closer라고 한다. 누가 먼저 연결을 끊느냐가 중요한 이유는 active closer 쪽에 TIME_WAIT 소켓이 생성되기 때문이다. 주의해야 할 부분은 **TIME_WAIT 소켓은 서버에서 생기는 것이 아니고 먼저 연결을 끊는 쪽에서 생성된다는 점이다.** 

그럼 서버에서 TIME_WAIT 소켓이 몇개나 있는지 어떻게 확인할 수 있을까? `netstat` 명령으로 확인할 수 있다.

```docker
root@ip-172-31-0-128:/home/ubuntu# netstat -napo |grep -i time_wait
tcp        0      0 172.31.0.128:33870      13.124.245.230:80       TIME_WAIT   -                    timewait (41.94/0/0)
```

출발지 IP가 172.31.0.128:33870이며, 목적지 IP가 13.124.245.230:80인 소켓이 있는데 현재 TIME_WAIT 상태이기 때문에 **타이머가 종료되어 커널로 다시 돌아갈 때까지는 사용할 수 없다.**

이처럼 TIME_WAIT 소켓이 많아지면 어떤 문제가 발생할까? 먼저 로컬 포트 고갈에 따른 애플리케이션 타임아웃이 발생할 수 있다. 리눅스에는 `net.ipv4.ip_local_port_range`라는 커널 파라미터가 있는데, 이 파라미터는 외부와 통신하기 위해 필요한 로컬 포트의 범위를 지정하는 역할을 한다. 커널은 프로세스가 외부와 통신하기 위해 소켓의 생성을 요청할 때 해당 소켓이 사용하게 될 로컬 포트에 `net.ipv4.ip_local_port_range`에 정의된 값들 중 하나를 넘겨준다. 이때 모든 로컬 포트가 TIME_WAIT 상태에 있다면 할당할 수 있는 로컬 포트가 없기 때문에 외부와 통신을 하지 못하게 되고, 이로 인해 애플리케이션에서는 타임 아웃이 발생할 수 있다.
