# 1.1 커널 정보 확인하기

커널 버전을 확인할 수 있는 방법은 여러가지다. 그중에서도 가장 대표적인 방법은 `uname` 명령을 사용하는 것으로, `uname -a` 명령을 입력하면 **커널 버전 관련 정보**가 나온다.

```bash
ubuntu@ip-172-31-0-157:~$ uname -a
Linux ip-172-31-0-157 6.14.0-1015-aws #15~24.04.1-Ubuntu SMP Tue Sep 23 22:44:48 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
```

위 서버의 커널 버전은 6.14.0-1015-aws로, x86 계열의 64비트 운영체제를 사용하고 있음을 알 수 있다.

`dmesg` 명령을 사용해서 몇가지 정보를 더 확인해보자. `dmesg`는 커널의 디버그 메시지로, **커널이 부팅할 때 나오는 메시지와 운영중에 발생하는 메시지를 볼 수 있게 해주는 명령어**다. `dmesg`로 커널이 메모리를 인식하는 과정과 하드웨어를 인식하고 드라이버를 올리는 과정, 그리고 부팅 시 적용된 커널 파라미터 등을 확인할 수 있다.

```bash
ubuntu@ip-172-31-0-157:~$ sudo dmesg | grep -i kernel | more
[    0.000000] KERNEL supported cpus:
[    0.000000] platform_pci_unplug: Netfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated NICs.
[    0.000000] platform_pci_unplug: Blkfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated disks.
               in your root= kernel command line option
[    0.038855] Booting paravirtualized kernel on Xen HVM
[    0.040363] Kernel command line: BOOT_IMAGE=/vmlinuz-6.14.0-1015-aws root=PARTUUID=cd553419-794d-4da4-9ba5-c355f5f9f74d ro console=tty1 console=ttyS0 nvme_core.io_timeout=4294967295 panic=-1
[    0.040443] Unknown kernel command line parameters "BOOT_IMAGE=/vmlinuz-6.14.0-1015-aws", will be passed to user space.
[    0.044562] Kernel/User page tables isolation: enabled
[    1.201955] Memory: 951048K/1048180K available (21448K kernel code, 4578K rwdata, 15128K rodata, 5252K init, 4312K bss, 90452K reserved, 0K cma-reserved)
[    1.201955] DMA: preallocated 128 KiB GFP_KERNEL pool for atomic allocations
[    1.201955] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations
[    1.201955] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations
[    1.788545] Loaded X.509 cert 'Build time autogenerated kernel key: b2dd1892589afbbb40cf0375596cc4d1b00e6512'
[    1.830209] Loaded X.509 cert 'Canonical Ltd. Kernel Module Signing: 88f752e560a1e0737e31163a466ad7b70a850c19'
[    2.014151] Loaded X.509 cert 'Build time autogenerated kernel key: b2dd1892589afbbb40cf0375596cc4d1b00e6512'
[    2.190778] Freeing unused kernel image (initmem) memory: 5252K
[    2.195917] Write protecting the kernel read-only data: 38912k
[    2.201622] Freeing unused kernel image (text/rodata gap) memory: 1076K
[    2.207979] Freeing unused kernel image (rodata/data gap) memory: 1256K
[    4.133466] systemd[1]: Listening on systemd-udevd-kernel.socket - udev Kernel Socket.
[    4.191436] systemd[1]: Mounting sys-kernel-debug.mount - Kernel Debug File System...
[    4.210458] systemd[1]: Mounting sys-kernel-tracing.mount - Kernel Trace File System...
[    4.355502] systemd[1]: Starting modprobe@configfs.service - Load Kernel Module configfs...
[    4.389465] systemd[1]: Starting modprobe@dm_mod.service - Load Kernel Module dm_mod...
[    4.424502] systemd[1]: Starting modprobe@drm.service - Load Kernel Module drm...
[    4.452526] systemd[1]: Starting modprobe@efi_pstore.service - Load Kernel Module efi_pstore...
[    4.470566] systemd[1]: Starting modprobe@fuse.service - Load Kernel Module fuse...
[    4.495496] systemd[1]: Starting modprobe@loop.service - Load Kernel Module loop...
[    4.549723] systemd[1]: Starting systemd-modules-load.service - Load Kernel Modules...
```

`dmesg`를 이용해 확인하는 커널 정보 외에 **현재 사용중인 커널의 컴파일 옵션**도 확인할 필요가 있다. 커널의 기능 중 컴파일 옵션에 포함이 되어야만 사용할 수 있는 기능들이 있기 때문이다.

```bash
root@ip-172-31-0-157:/home/ubuntu# cat /boot/config-`uname -r` | more
#
# Automatically generated file; DO NOT EDIT.
# Linux/x86_64 6.14.11 Kernel Configuration
#
CONFIG_CC_VERSION_TEXT="x86_64-linux-gnu-gcc-13 (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0"
CONFIG_CC_IS_GCC=y
CONFIG_GCC_VERSION=130300
CONFIG_CLANG_VERSION=0
CONFIG_AS_IS_GNU=y
CONFIG_AS_VERSION=24200
CONFIG_LD_IS_BFD=y
CONFIG_LD_VERSION=24200
CONFIG_LLD_VERSION=0
CONFIG_RUSTC_VERSION=108001
CONFIG_RUST_IS_AVAILABLE=y
CONFIG_RUSTC_LLVM_VERSION=180103
CONFIG_CC_CAN_LINK=y
CONFIG_CC_CAN_LINK_STATIC=y
CONFIG_CC_HAS_ASM_GOTO_OUTPUT=y
CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT=y
CONFIG_TOOLS_SUPPORT_RELR=y
CONFIG_CC_HAS_ASM_INLINE=y
CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
CONFIG_LD_CAN_USE_KEEP_IN_OVERLAY=y
CONFIG_PAHOLE_VERSION=125
CONFIG_IRQ_WORK=y
CONFIG_BUILDTIME_TABLE_SORT=y
CONFIG_THREAD_INFO_IN_TASK=y

#
# General setup
#
CONFIG_INIT_ENV_ARG_LIMIT=32
# CONFIG_COMPILE_TEST is not set
# CONFIG_WERROR is not set
CONFIG_LOCALVERSION=""
# CONFIG_LOCALVERSION_AUTO is not set
CONFIG_BUILD_SALT=""
CONFIG_HAVE_KERNEL_GZIP=y
CONFIG_HAVE_KERNEL_BZIP2=y
CONFIG_HAVE_KERNEL_LZMA=y
CONFIG_HAVE_KERNEL_XZ=y
CONFIG_HAVE_KERNEL_LZO=y
CONFIG_HAVE_KERNEL_LZ4=y
CONFIG_HAVE_KERNEL_ZSTD=y
# CONFIG_KERNEL_GZIP is not set
# CONFIG_KERNEL_BZIP2 is not set
# CONFIG_KERNEL_LZMA is not set
# CONFIG_KERNEL_XZ is not set
# CONFIG_KERNEL_LZO is not set
# CONFIG_KERNEL_LZ4 is not set
CONFIG_KERNEL_ZSTD=y
CONFIG_DEFAULT_INIT=""
CONFIG_DEFAULT_HOSTNAME="(none)"
CONFIG_VERSION_SIGNATURE="Ubuntu 6.14.0-1015.15~24.04.1-aws 6.14.11"
CONFIG_SYSVIPC=y
CONFIG_SYSVIPC_SYSCTL=y
CONFIG_SYSVIPC_COMPAT=y
CONFIG_POSIX_MQUEUE=y
CONFIG_POSIX_MQUEUE_SYSCTL=y
CONFIG_WATCH_QUEUE=y
CONFIG_CROSS_MEMORY_ATTACH=y
CONFIG_USELIB=y
CONFIG_AUDIT=y
CONFIG_HAVE_ARCH_AUDITSYSCALL=y
CONFIG_AUDITSYSCALL=y

#
# IRQ subsystem
#
CONFIG_GENERIC_IRQ_PROBE=y
CONFIG_GENERIC_IRQ_SHOW=y
CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
CONFIG_GENERIC_PENDING_IRQ=y
CONFIG_GENERIC_IRQ_MIGRATION=y
CONFIG_HARDIRQS_SW_RESEND=y
CONFIG_GENERIC_IRQ_CHIP=y
CONFIG_IRQ_DOMAIN=y
```

`ftrace`와 같이 커널 함수 레벨의 추적이 필요할 경우, `CONFIG_FUNCTION_TRACER`와 같은 몇몇 옵션들이 컴파일 옵션에 포함되어야 한다.

```bash
root@ip-172-31-0-157:/home/ubuntu# cat /boot/config-`uname -r` | grep -i config_function_tracer
CONFIG_FUNCTION_TRACER=y
```

# 1.2 CPU 정보 확인하기

리눅스에서는 `dmidecode` 명령을 통해 하드웨어의 정보를 확인한다. `dmidecode` 명령만 입력하면 너무 많은 정보가 나오기 때문에 키워드를 사용해서 필요한 정보만 확인하는 것이 좋다. `man` 명령을 통해 살펴보면, `dmidecode` 명령에서 사용할 수 있는 키워드는 총 9가지가 있다.

```jsx
Additionally, type 126 is used for disabled entries and type 127 is an end-of-table marker. Types 128 to 255 are for OEM-specific data.  dmidecode will display these entries by default, but  it  can
only decode them when the vendors have contributed documentation or code for them.

Keywords can be used instead of type numbers with --type.  Each keyword is equivalent to a list of type numbers:

Keyword     Types
──────────────────────────────
bios        0, 13
system      1, 12, 15, 23, 32
baseboard   2, 10, 41
chassis     3
processor   4
memory      5, 6, 16, 17
cache       7
connector   8
slot        9
```

이 중에서 CPU와 BIOS의 정보를 확인하는데 필요한 키워드는 `bios`, `system`과 `processor`이다.

먼저 `bios` 키워드의 결과를 살펴보자.

```bash
root@ip-172-31-0-157:/home/ubuntu# dmidecode -t bios
# dmidecode 3.5
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: Xen
        Version: 4.11.amazon
        Release Date: 08/24/2006
        Address: 0xE8000
        Runtime Size: 96 kB
        ROM Size: 64 kB
        Characteristics:
                PCI is supported
                EDD is supported
                Targeted content distribution is supported
        BIOS Revision: 4.11
```

`bios` 키워드는 보통 특정 BIOS 버전에 문제가 있다는 보고가 있고, 내가 사용하는 버전이 이 버전에 해당하는지를 확인할 때 주로 사용한다. 위 정보를 보면 이 서버는 Xen에서 만든 서버이며, BIOS 버전은 2006/08/24에 발표된 4.11.amazon버전이고, BIOS 버전은 4.11 버전이다.

```bash
root@ip-172-31-0-157:/home/ubuntu# dmidecode -t system
# dmidecode 3.5
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0100, DMI type 1, 27 bytes
System Information
        Manufacturer: Xen
        Product Name: HVM domU
        Version: 4.11.amazon
        Serial Number: ec2cb7b3-daf8-74c2-6305-b8ff60aede4a
        UUID: ec2cb7b3-daf8-74c2-6305-b8ff60aede4a
        Wake-up Type: Power Switch
        SKU Number: Not Specified
        Family: Not Specified

Handle 0x2000, DMI type 32, 11 bytes
System Boot Information
        Status: No errors detected
```

위 결과는 `dmidecode` 명령 중에 가장 많이 사용하는 키워드인 `system` 이다. 장비는 Xen에서 만든 HVM domU 모델이다. 장비의 모델명은 어떤 제조사에서 만들었느냐만큼이나 중요한 정보이다. 모델명을 통해서 해당 장비가 어느 정도의 성능을 낼 수 있는지 확인할 수 있기 때문이다.

```bash
root@ip-172-31-0-157:/home/ubuntu# dmidecode -t processor
# dmidecode 3.5
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x0401, DMI type 4, 35 bytes
Processor Information
        Socket Designation: CPU 1
        Type: Central Processor
        Family: Other
        Manufacturer: Intel
        ID: F1 06 04 00 FF FB 8B 17
        Version: Not Specified
        Voltage: Unknown
        External Clock: Unknown
        Max Speed: 2300 MHz
        Current Speed: 2300 MHz
        Status: Populated, Enabled
        Upgrade: Other
        L1 Cache Handle: Not Provided
        L2 Cache Handle: Not Provided
        L3 Cache Handle: Not Provided
        Serial Number: Not Specified
        Asset Tag: Not Specified
        Part Number: Not Specified
```

위 결과는 `processor` 키워드의 결과로, 장비의 CPU 정보를 확인할 수 있다.

여기서 소켓과 코어에 대한 구분이 중요한데, **소켓은 물리적인 CPU의 개수를 의미하고 코어는 물리적인 CPU 안에 몇 개의 컴퓨팅 코어가 있는지를 뜻한다.** 이 정보는 `dmidecode` 외에 `/proc` 에 있는 정보를 바탕으로도 확인할 수 있다.

```bash
root@ip-172-31-0-157:/home/ubuntu# cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 79
model name      : Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz
stepping        : 1
microcode       : 0xb000040
cpu MHz         : 2300.199
cache size      : 46080 KB
physical id     : 0
siblings        : 1
core id         : 0
cpu cores       : 1
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 13
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm cpuid_fault pti fsgsbase bmi1 avx2 smep bmi2 erms invpcid xsaveopt
bugs            : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit mmio_stale_data bhi its
bogomips        : 4599.99
clflush size    : 64
cache_alignment : 64
address sizes   : 46 bits physical, 48 bits virtual
power management:
```

CPU에 대한 정보는 `lscpu` 명령을 이용해서도 확인할 수 있다.

```bash
root@ip-172-31-0-157:/home/ubuntu# lscpu
Architecture:                x86_64
  CPU op-mode(s):            32-bit, 64-bit
  Address sizes:             46 bits physical, 48 bits virtual
  Byte Order:                Little Endian
CPU(s):                      1
  On-line CPU(s) list:       0
Vendor ID:                   GenuineIntel
  BIOS Vendor ID:            Intel
  Model name:                Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz
    BIOS Model name:           CPU @ 2.3GHz
    BIOS CPU family:         1
    CPU family:              6
    Model:                   79
    Thread(s) per core:      1
    Core(s) per socket:      1
    Socket(s):               1
    Stepping:                1
    BogoMIPS:                4599.99
    Flags:                   fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clf
                             lush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl x
                             topology cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4
                             _2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervi
                             sor lahf_lm abm cpuid_fault pti fsgsbase bmi1 avx2 smep bmi2 erms invpcid x
                             saveopt
Virtualization features:     
  Hypervisor vendor:         Xen
  Virtualization type:       full
Caches (sum of all):         
  L1d:                       32 KiB (1 instance)
  L1i:                       32 KiB (1 instance)
  L2:                        256 KiB (1 instance)
  L3:                        45 MiB (1 instance)
NUMA:                        
  NUMA node(s):              1
  NUMA node0 CPU(s):         0
Vulnerabilities:             
  Gather data sampling:      Not affected
  Ghostwrite:                Not affected
  Indirect target selection: Mitigation; Aligned branch/return thunks
  Itlb multihit:             KVM: Mitigation: VMX unsupported
  L1tf:                      Mitigation; PTE Inversion
  Mds:                       Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unkno
                             wn
  Meltdown:                  Mitigation; PTI
  Mmio stale data:           Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unkno
                             wn
  Reg file data sampling:    Not affected
  Retbleed:                  Not affected
  Spec rstack overflow:      Not affected
  Spec store bypass:         Vulnerable
  Spectre v1:                Mitigation; usercopy/swapgs barriers and __user pointer sanitization
  Spectre v2:                Mitigation; Retpolines; STIBP disabled; RSB filling; PBRSB-eIBRS Not affect
                             ed; BHI Retpoline
  Srbds:                     Not affected
  Tsa:                       Not affected
  Tsx async abort:           Not affected
```

# 1.3 메모리 정보 확인하기

`dmidecode`의 키워드들 중 `memory` 키워드로 각 메모리 슬롯에 있는 메모리의 정보 및 제조사까지 확인할 수 있다.

```bash
root@ip-172-31-0-157:/home/ubuntu# dmidecode -t memory
# dmidecode 3.5
Getting SMBIOS data from sysfs.
SMBIOS 2.7 present.

Handle 0x1000, DMI type 16, 19 bytes
Physical Memory Array
        Location: Other
        Use: System Memory
        Error Correction Type: Multi-bit ECC
        Maximum Capacity: 1 GB
        Error Information Handle: Not Provided
        Number Of Devices: 1

Handle 0x1100, DMI type 17, 34 bytes
Memory Device
        Array Handle: 0x1000
        Error Information Handle: 0x0000
        Total Width: 64 bits
        Data Width: 64 bits
        Size: 1 GB
        Form Factor: DIMM
        Set: None
        Locator: DIMM 0
        Bank Locator: Not Specified
        Type: RAM
        Type Detail: None
        Speed: Unknown
        Manufacturer: Not Specified
        Serial Number: Not Specified
        Asset Tag: Not Specified
        Part Number: Not Specified
        Rank: Unknown
        Configured Memory Speed: Unknown
```

`memory` 키워드는 크게 Physical Memory Array와 Memory Device의 두 영역으로 나눌 수 있다.

**Physical Memory Array는 하나의 CPU 소켓에 함께 할당된 물리 메모리의 그룹**을 의미한다. 최근의 프로세서는 NUMA라는 개념을 이용해 각각의 CPU가 사용할 수 있는 로컬 메모리를 제공한다. Physical Memory Array는 바로 이 개념에서 시작하며, 우리가 지금 보고 있는 시스템은 **2개의 CPU 소켓이 있는 서버이기 때문에 Physical memory Array도 2개가 있다.** 그리고 각각의 Physical Memory Array는 총 9개의 메모리를 꽂을 수 있으며 최대로 꽂을 수 있는 양은 192GB이다.

**Memory Device는 실제로 시스템에 꽂혀있는 메모리**를 의미하며, 메모리의 용량이 얼마인지, 제조사는 어디인지 볼 수 있다.

```bash
root@ip-172-31-0-157:/home/ubuntu# dmidecode -t memory | grep -i size:
        Size: 1 GB
```

`grep` 명령과 조합해 확인해보면, 1GB 메모리가 1개 꽂혀있는 것을 확인할 수 있다. 이를 통해 전체 메모리의 용량이 1GB라는 결론이 나온다. 이 크기가 `free` 명령을 통해 확인한 전체 메모리 크기와 다르다면 시스템의 메모리 인식에 뭔가 문제가 있는 것이다.

# 1.4 디스크 정보 확인하기

아래는 `df` 명령의 결과이다.

```jsx
root@ip-172-31-0-157:/home/ubuntu# df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/root       6.8G  1.8G  5.0G  27% /
tmpfs           479M     0  479M   0% /dev/shm
tmpfs           192M  860K  191M   1% /run
tmpfs           5.0M     0  5.0M   0% /run/lock
/dev/xvda16     881M   89M  730M  11% /boot
/dev/xvda15     105M  6.2M   99M   6% /boot/efi
tmpfs            96M   12K   96M   1% /run/user/1000
root@ip-172-31-0-157:/home/ubuntu# 
```

위 서버는 총 3개의 파티션(디스크와 같은 물리적 저장 장치를 가 독립적으로 관리할 수 있는 논리적 단위로 나누는 과정)이 있으며, 각각의 파티션은 `/`, `/boot`, `/boot/efi`에 마운트되어 있다. 또한, 디스크는 `/dev/xvda` 라는 이름으로 시스템에 네이밍되어 있다. 디스크의 방식에 따라서 `/dev/hda`일 수도 있고 `/dev/vda`일 수도 있다.

[15-3 파티션과 마운팅](https://wikidocs.net/312556)

`sda`와 `hda`의 차이점을 살펴보자. 시스템이 디스크와 통신하기 위해 사용하는 것 중에 컨트롤러라는 부품이 있다. **디스크를 사용하려는 쪽과 실제 디스크 사이에서 통신이 원활히 이루어질 수 있도록 일종의 중개자 역할을 하는 부품**인데, 이 부품에도 여러가지 타입이 있다. 그중 가장 대표적인 것이 IDE 타입과 SCSI 타입이다. 쉽게 말해 IDE는 개인용 컴퓨터를 위한 방식, SCSI는 서버용 컴퓨터를 위한 방식이라고 생각하면 된다. SCSI 방식은 더 많은 장치를 연결할 수 있어서 확장성이 좋고 더 빠른 접근 속도를 제공하기 때문이다. IDE 방식의 디스크는 `hda`로, SCSI 방식의 디스크와 최근에 나오는 SATA, SAS와 같은 일반적인 하드 디스크는 `sda`로 표시된다.

[(펌) IDE, SATA, SCSI, SAS, SSD란?](https://serverstudy.tistory.com/7)

`vda`는 가상 서버에서 흔히 볼 수 있는 디스크 타입이다. XEN, KVM과 같이 하이퍼바이저(Hypervisor) 위에서 동작 중인 서버들에서 주로 볼 수 있다.

이렇게 `df` 명령을 통해서도 현재 시스템을 구성하고 있는 파티션과 디스크의 타입 정보 정도는 간략하게 알 수 있다. 그럼 디스크의 **물리적인 정보**는 어떻게 확인할 수 있을까? 보통은 하드웨어 제조사에서 제공해주는 다양한 툴을 사용할 수도 있지만, `smartctl`이라는 툴을 이용하면 확인할 수 있다.

`df` 명령을 통해 확인한 디스크의 위치(`/dev/sda`)를 입력하면 간단한 정보를 볼 수 있다. 서버의 경우 대부분 RAID 컨트롤러가 달려 있기 때문에 바로 정확한 정보를 볼 수 없다. **`/dev/sda` 는 Logical Volume, 즉 RAID 컨트롤러를 통해서 만들어진 논리적인 볼륨이며, 실제 물리적 디스크의 정보까지는 확인할 수 없다.** 하지만 `smartctl`의 옵션을 잘 사용하면 물리적 디스크의 정보까지 확인할 수 있다. (`smartctl`은 클라우드 EC2에서는 동작하지 않는다.)

[RAID란?(RAID 종류 및 작동 방식)](https://ilovestorage.tistory.com/16)

[[Linux] smartctl 을 이용한 디스크 점검 방법](https://servermon.tistory.com/568)

`smartctl` 명령에 `-d` 옵션을 적용하면 어떨까? `smartctl` 명령은 RAID 컨트롤러의 드라이버에 따라 `-d` 옵션 뒤에 추가 옵션을 통해 디스크의 정보를 볼 수 있도록 해준다. 해당 디스크 베이에 꽂혀있는 디스크의 상세한 정보를 알 수 있다. 이를 통해 특정 펌웨어 버전에서 버그나 이슈 등이 발견되었을 때 자신의 서버가 이에 해당하는지를 확인할 수 있다.

# 1.5 네트워크 정보 확인하기

네트워크 카드의 정보는 `lspci` 명령을 통해서 확인할 수 있다.

```bash
root@ip-172-31-0-157:/home/ubuntu# lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 01)
00:02.0 VGA compatible controller: Cirrus Logic GD 5446
00:03.0 Unassigned class [ff80]: XenSource, Inc. Xen Platform Device (rev 01)
```

이번엔 `ethtool` 명령을 통해서 연결 상태를 확인해보자.

```bash
root@ip-172-31-0-157:/home/ubuntu# ethtool enX0
Settings for enX0:
        Link detected: yes
```

`ethtool` 을 통해서 확인할 수 있는 정보에도 상당히 중요한 내용이 포함되어 있다. 우선 해당 네트워크 카드가 어느 정도의 속도까지 지원이 가능한지, 그리고 현재 연결되어 있는 속도는 얼마인지, 네트워크 연결은 정상적인지를 확인할 수 있다.

`ethtool`의 `-g` 옵션을 이용하면 Ring Buffer의 크기를 확인할 수 있다. **Ring Buffer는 네트워크 카드의 버퍼 공간**을 의미한다. 케이블을 통해서 들어오는 패킷 정보는 제일 먼저 네트워크 카드의 Ring Buffer라는 버퍼 공간에 복사된다. 그 후 커널에 패킷의 도착을 알리고 패킷의 정보를 다시 커널로 복사한다. 그렇기 때문에 **Ring Buffer의 크기가 작다면 네트워크 성능 저하를 일으킬 수 있다.** 항상 maximums 값과 current의 값이 같도록 세팅해야 한다.

`-G` 옵션은 위에서 확인한 Ring Buffer의 값을 설정할 때 사용되는 옵션이다. `-g` 를 통해서 확인한 결과 current 값이 maximums 값보다 작다면 `-G` 옵션을 통해서 값을 설정할 수 있다. 아래는 `-G` 옵션을 이용해 임의의 값을 설정하는 예제이다.

```bash
root@ip-172-31-0-157:/home/ubuntu# ethtool -G enX0 rx 255
netlink error: Operation not supported
```

다음은 `-k`, `-K` 옵션이다. `-k` 옵션으로 현재 사용중인 네트워크 카드의 다양한 성능 최적화 옵션을 확인할 수 있다. `-K` 옵션은 `-k` 옵션으로 확인한 네트워크 카드의 성능 최적화 옵션을 설정할 때 사용된다.

네트워크 카드는 단순하게 패킷을 주고 받는 기능 외에도 더 빠르게 패킷을 주고 받을 수 있게 해주는 다양한 기능을 제공한다. 여기에서 가장 중요한 기능중 하나가 tcp-offload 기능인데, **이 기능은 MTU 이상의 크기를 가지는 패킷의 분할 작업을 CPU가 아닌 네트워크 카드가 직접 함으로써 CPU의 부담을 줄이고 패킷 처리 성능을 높이는 기능**이다. 하지만 이 기능은 특정한 환경, 예를 들어 네트워크 대역폭이 아주 높은 서버들에서 이슈를 일으킬 수 있기 때문에 불특정한 패킷 유실이 자주 일어나는 것 같다면 기능을 OFF하는 편이 좋다.

[https://en.wikipedia.org/wiki/TCP_offload_engine#:~:text=TCP 오프로드 엔진 ( TOE )은 일부,처리를 네트워크 컨트롤러로 오프로드하는 데 사용되는 기술입니다](https://en.wikipedia.org/wiki/TCP_offload_engine#:~:text=TCP%20%EC%98%A4%ED%94%84%EB%A1%9C%EB%93%9C%20%EC%97%94%EC%A7%84%20(%20TOE%20)%EC%9D%80%20%EC%9D%BC%EB%B6%80,%EC%B2%98%EB%A6%AC%EB%A5%BC%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC%EB%A1%9C%20%EC%98%A4%ED%94%84%EB%A1%9C%EB%93%9C%ED%95%98%EB%8A%94%20%EB%8D%B0%20%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%20%EA%B8%B0%EC%88%A0%EC%9E%85%EB%8B%88%EB%8B%A4).

[https://docs.aws.amazon.com/ko_kr/prescriptive-guidance/latest/sql-server-ec2-best-practices/tcp-rss.html#:~:text=TCP 오프로딩(TCP Chimney 오프로드 기능)은 프로세서에서 네트워크,CPU가 다른 작업에 사용할 수 있도록 합니다](https://docs.aws.amazon.com/ko_kr/prescriptive-guidance/latest/sql-server-ec2-best-practices/tcp-rss.html#:~:text=TCP%20%EC%98%A4%ED%94%84%EB%A1%9C%EB%94%A9(TCP%20Chimney%20%EC%98%A4%ED%94%84%EB%A1%9C%EB%93%9C%20%EA%B8%B0%EB%8A%A5)%EC%9D%80%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%97%90%EC%84%9C%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC,CPU%EA%B0%80%20%EB%8B%A4%EB%A5%B8%20%EC%9E%91%EC%97%85%EC%97%90%20%EC%82%AC%EC%9A%A9%ED%95%A0%20%EC%88%98%20%EC%9E%88%EB%8F%84%EB%A1%9D%20%ED%95%A9%EB%8B%88%EB%8B%A4).

TCP 오프로드(TCP Offload)는 **CPU가 담당하던 TCP/IP 패킷 처리 부담을 네트워크 어댑터(NIC)의 전용 하드웨어(TCP Offload Engine, TOE)로 옮겨, CPU는 애플리케이션 처리에 집중하고 네트워크 성능을 향상시키는 기술**입니다. 이는 특히 대용량 데이터 전송 환경에서 성능 저하의 주범인 TCP/IP 오버헤드를 줄여 시스템 효율을 높이는 데 중요하며, 고성능 컴퓨팅이나 iSCSI, RDMA 환경에서 필수적입니다. 

마지막으로 `-i` 옵션이다. 네트워크 카드의 커널 모듈 정보를 표시한다.

```bash
root@ip-172-31-0-157:/home/ubuntu# ethtool -i enX0
driver: vif
version: 6.14.0-1015-aws
firmware-version: 
expansion-rom-version: 
bus-info: vif-0
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: no
supports-priv-flags: no
```

이 명령을 통해 **사용중인 네트워크 카드가 어떤 커널 드라이버를 사용하는지, 버전이 몇인지**를 알 수 있다. 이는 특정 커널 드라이버의 버전에서 문제가 생겼을 경우 내가 사용하는 버전이 여기에 해당하는지 아닌지를 판단할 때 필요하다.
